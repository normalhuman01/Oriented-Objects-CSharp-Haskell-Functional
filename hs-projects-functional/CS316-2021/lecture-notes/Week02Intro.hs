module Week02Intro where

-- A function that makes decisions, based on whether or not too things are equal.
isMember :: Eq a => a -> [a] -> Bool
isMember x []     = False 
isMember x (y:ys) = --if x == y then True else isMember x ys
                    x == y || isMember x ys

-- Another way, using guards:
isMember2 :: Eq a => a -> [a] -> Bool
isMember2 x [] = False
isMember2 x (y:ys)
    | x == y    = True
    | otherwise = isMember2 x ys

-- Another way, using case
isMember3 :: Eq a => a -> [a] -> Bool
isMember3 x [] = False 
isMember3 x (y:ys) = case x == y of
  False -> isMember3 x ys
  True  -> True

-- Check to see if a list is sorted (in ascending order)
isSorted :: Ord a => [a] -> Bool
isSorted []       = True
isSorted [x]      = True
isSorted (x:y:ys) = if x <= y then isSorted (y:ys) else False

-- Writing out the steps to see what is required:
--
--    isSorted (1:2:3:[])
-- == if 1 <= 2 then isSorted (2:3:[]) else False
-- == isSorted (2:3:[])
-- == if 2 <= 3 then isSorted (3:[]) else False
-- == isSorted (3:[])
-- == True

isSorted2 :: Ord a => [a] -> Bool
isSorted2 []       = True
isSorted2 [x]      = True
isSorted2 (x:y:ys) =
    case compare x y of
        GT -> False 
        _  -> isSorted2 (y:ys)

data Tree a
  = Leaf 
  | Node (Tree a) a (Tree a)
  deriving Show 

-- An example where using 'compare' is clearer
isInTree :: Ord a => a -> Tree a -> Bool
isInTree x Leaf = False
isInTree x (Node l d r) =
    -- Using if-then-else:
 {-      if x == d then True
    else if x < d then isInTree x l
    else isInTree x r -}
    -- Using cases:
    case compare x d of
        EQ -> True
        LT -> isInTree x l
        GT -> isInTree x r

-- counting duplicates in a sorted list

-- [1,1,1,2,2,2,3,4,4,5]
-- [(1,3),(2,3),(3,1),(4,2),(5,1)]  -- each element of the original is paired with its count

-- An example of using a helper function to maintain some state when
-- processing a list
countDuplicates :: Eq a => [a] -> [(a,Int)]
countDuplicates []     = []
countDuplicates (x:xs) = helper x 1 xs
  where
      -- helper <thing we are counting> <count> <things left to count>
      helper x c [] = [(x,c)]
      helper x c (y:ys)
        | x == y    = helper x (c+1) ys
        | otherwise = (x,c) : helper y 1 ys -- "the rest of the list is generated by:
                                            --  looking for 'y' in 'ys', and we've already seen 1"

--    countDuplicates (1:1:2:[])
-- == helper 1 1 (1:2:[])
-- == helper 1 2 (2:[])
-- == (1,2) : helper 2 1 []
-- == (1,2) : (2,1) : []
-- == [(1,2),(2,1)]


-------------------------------------------------------------------------------------
type Document = [DocumentBlock]

data DocumentBlock
    = Paragraph  String
    | List       [String]
    | Heading    String
    | SubHeading String
    deriving Show 

testDocument :: Document
testDocument =
    [ Heading "This is a document"
    , SubHeading "Part 1"
    , Paragraph "Paragraph 1"
    , SubHeading "Part 2 (Lists)"
    , List [ "item 1"
           , "item 2"
           ]
    ]

documentBlockToHTML :: DocumentBlock -> String
documentBlockToHTML (Paragraph text)  = "<p>" ++ text ++ "</p>"
documentBlockToHTML (List items)      = "<ul>" ++ helper items ++ "</ul>"
  where helper [] = ""
        helper (item:items) = "<li>" ++ item ++ "</li>" ++ helper items
documentBlockToHTML (Heading text)    = "<h1>" ++ text ++ "</h1>"
documentBlockToHTML (SubHeading text) = "<h2>" ++ text ++ "</h2>"

-- 1. Writing helper functions to wrap pieces of text in tags
--       tag "p" text  ===> "<p>" ++ text ++ "</p>"
-- 2. Writing specific helper functions for each kind of tag
--       p :: String -> String
-- 3. Defining your own HTML type
--      documentToHTML :: Document -> HTML
--      htmlToString   :: HTML -> String

documentToHTML :: Document -> String
documentToHTML []             = ""
documentToHTML (block:blocks) = documentBlockToHTML block ++ documentToHTML blocks

