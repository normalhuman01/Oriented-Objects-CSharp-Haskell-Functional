module Demo where

sumIt :: Int -> Int -> Int
sumIt x y = x + y

{- Ленивая стратегия:
sumIt (2 + 3) 4 -- сначала осуществляем подстановку
 ~> (2 + 3) + 4 -- вычисляем значение первого аргумента
 ~> 5 + 4
 ~> 9
-}

{- Альтернативная ленивой энергичная стратегия:
sumIt (2 + 3) 4 -- сначала вычисляем значение первого аргумента
 ~> sumIt 5 4 -- вызывается функция
 ~> 5 + 4
 ~> 9
-}


add7 :: Int -> Int -> Int
add7 x y = x + 7 -- второй аргумент игнорируется

{-
Ленивая модель:
add7 1 (2 + 3)
 ~> 1 + 7
 ~> 8

Энергичная модель:
add7 1 (2 + 3)
 ~> add7 1 5
 ~> 1 + 7
 ~> 8
-}


dup :: Int -> (Int,Int)
dup x = (x,x)

{-
Ленивая стратегия вычислений:
dup (2+3)
 ~> (2+3,2+3)
 ~> (5,2+3)
 ~> (5,5)

Энергичная стратегия вычислений:
dup (2+3)
 ~> dup 5
 ~> (5,5)
-}


{- Механизм разделения:
dup (2+3)
 ~> (p,p)  p=2+3
 ~> (5,p)  p=5
 ~> (5,5)
-}