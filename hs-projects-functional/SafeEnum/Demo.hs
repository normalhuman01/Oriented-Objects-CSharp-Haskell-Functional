module Demo where

-- Реализуйте класс типов

class (Eq a, Enum a, Bounded a) => SafeEnum a where
  ssucc :: a -> a
  ssucc x | x == maxBound = minBound
          | otherwise = succ x
  
  spred :: a -> a
  spred x | x == minBound = maxBound
          | otherwise = pred x
{- обе функции которого ведут себя как succ и pred стандартного класса Enum, однако являются тотальными, то есть не останавливаются с ошибкой на наибольшем и наименьшем значениях типа-перечисления соответственно, а обеспечивают циклическое поведение. Ваш класс должен быть расширением ряда классов типов стандартной библиотеки, так чтобы можно было написать реализацию по умолчанию его методов, позволяющую объявлять его представителей без необходимости писать какой бы то ни было код. Например, для типа Bool должно быть достаточно написать строку -}

{- Такой код не канает:
  ssucc maxBound = minBound
  ssucc x = succ x
потому что maxBound - это не образец, а обычный идентификатор, который рассматривается как имя формального параметра функции. То что это имя совпадает с именем функции (константы) приводит лишь к тому, что имя этой функции затеняется в выражении справа от знака равенства. В качестве образцов (опровержимых) могут использоваться только имена конструкторов данных. -}




instance SafeEnum Bool
{- и получить возможность вызывать
GHCi> ssucc False
True
GHCi> ssucc True
False
-}

instance SafeEnum Char
instance SafeEnum Int
instance SafeEnum ()
